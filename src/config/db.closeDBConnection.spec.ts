`import sqlite3 from 'sqlite3'; // Import types for mocking\nimport path from 'path'; // db.ts uses path\n\n// --- Mocking Dependencies ---\n\n// Mock environment variables if needed (optional, can set process.env directly)\n// jest.mock('dotenv', () => ({ config: jest.fn() }));\n\n// Store mock instances and control functions accessible within the test scope\n// We need these to control the behavior of the mocked sqlite3 instance.\nlet mockDbInstance: jest.Mocked<sqlite3.Database>;\nlet capturedConstructorCallback: (err: Error | null) => void;\nlet capturedPragmaCallback: (err: Error | null) => void;\nlet capturedCloseCallback: (err: Error | null) => void;\nlet mockRunFn: jest.Mock;\nlet mockCloseFn: jest.Mock;\nlet mockOnFn: jest.Mock;\n\n/**\n * Define the mock implementation for the sqlite3.Database constructor.\n * This function will be called whenever 'new sqlite3.Database()' is executed in db.ts.\n */\nconst MockDatabaseConstructor = jest.fn().mockImplementation(function(this: any, filename: string, callback: (err: Error | null) => void) {\n    // Capture the callback provided to the constructor by db.ts.\n    // This allows tests to trigger connection success or failure asynchronously.\n    capturedConstructorCallback = callback;\n\n    // Define mock implementations for the database instance methods used by db.ts.\n    // These mocks will be attached to the object returned by the constructor ('this').\n\n    // Mock the 'run' method (used for PRAGMA)\n    mockRunFn = jest.fn().mockImplementation((sql: string, paramsOrCallback: any, callback?: any) => {\n        const actualCallback = typeof paramsOrCallback === 'function' ? paramsOrCallback : callback;\n\n        // Capture the callback specifically for the PRAGMA command to control its outcome in tests.\n        if (sql.toUpperCase().startsWith('PRAGMA FOREIGN_KEYS')) {\n            capturedPragmaCallback = actualCallback;\n        } else if (actualCallback) {\n            // Provide a default success behavior for any other 'run' calls if needed.\n            // Uses process.nextTick to simulate async behavior.\n            process.nextTick(() => actualCallback?.call({ lastID: 1, changes: 1 } as sqlite3.RunResult, null));\n        } else {\n            // If no callback is provided, resolve immediately\n             return Promise.resolve();\n        }\n        return this; // Return the mock instance ('this') to allow method chaining if any.\n    });\n\n    // Mock the 'close' method\n    mockCloseFn = jest.fn().mockImplementation((callback: (err: Error | null) => void) => {\n        // Capture the callback provided to 'close' to control its outcome in tests.\n        capturedCloseCallback = callback;\n\n        // Simulate async behavior using process.nextTick (or setTimeout(0))\n        process.nextTick(() => {\n            if (callback) {\n                // Default: Simulate successful close\n                callback(null);\n            }\n        });\n    });\n\n    // Mock the 'on' method (used for error handling on the db instance)\n    mockOnFn = jest.fn();\n\n    // Assign the mocked methods to the instance being created ('this').\n    this.run = mockRunFn;\n    this.close = mockCloseFn;\n    this.on = mockOnFn;\n    // Add mocks for other sqlite3.Database methods (e.g., get, all, prepare) if they were used in db.ts.\n\n    // Store a reference to the created mock instance so tests can assert against its methods.\n    mockDbInstance = this as jest.Mocked<sqlite3.Database>;\n\n    // The constructor in JS implicitly returns 'this'.\n    return this;\n});\n\n// Apply the mock to the 'sqlite3' module.\njest.mock('sqlite3', () => {\n    // The mock needs to export properties matching the real 'sqlite3' module.\n    return {\n        // Provide the mock constructor.\n        Database: MockDatabaseConstructor,\n        // Mock the 'verbose' function. db.ts calls sqlite3.verbose().Database(...).\n        // So, verbose() needs to return an object containing the mock constructor.\n        verbose: jest.fn(() => ({\n            Database: MockDatabaseConstructor,\n        })),\n        // Define any constants like OPEN_READWRITE if db.ts uses them directly (it doesn't currently).\n        // OPEN_READWRITE: jest.fn(),\n        // OPEN_CREATE: jest.fn(),\n    };\n});\n\n\n// --- Test Suite ---\n\n// Import the module *under test* AFTER mocks are defined.\n// We are testing the actual functions from db.ts.\nimport { closeDBConnection } from './db';\n\n// Enable Jest's fake timers to control process.nextTick, setTimeout, etc. used in mocks/async operations.\njest.useFakeTimers();\n\n\ndescribe('closeDBConnection', () => {\n    beforeEach(() => {\n        // --- Test Setup ---\n        // 1. Reset all Jest mocks (clears call counts, implementations set by mockImplementationOnce, etc.)\n        jest.clearAllMocks();\n\n        // 2. Reset the state of the db.ts module. This is crucial because db.ts uses module-level\n        //    variables (db, connectionPromise) to implement the singleton pattern. Resetting ensures\n        //    each test starts with a clean slate (db = null, connectionPromise = null).\n        jest.resetModules();\n\n        // 3. Reset any manually captured callbacks or variables used for mock control.\n        //    Ensures mocks behave predictably based on the current test setup.\n        capturedConstructorCallback = (err: Error | null) => { /* no-op */ };\n        capturedPragmaCallback = (err: Error | null) => { /* no-op */ };\n        capturedCloseCallback = (err: Error | null) => { /* no-op */ };\n\n        // 4. Ensure environment variables are reset or set as needed for the specific test.\n        //    The default state is no DATABASE_PATH override.\n        delete process.env.DATABASE_PATH;\n\n        // Note: Because of jest.resetModules(), if we needed to re-import db.ts *within* a test\n        // (e.g., after changing an env var), we'd use:\n        // const { getDBConnection } = require('./db');\n        // However, for most tests, the top-level import combined with beforeEach reset is sufficient.\n    });\n    afterEach(async () => {\n        // --- Test Teardown ---\n        // 1. Ensure any potentially open connection from a test is closed.\n        //    This uses the *actual* closeDBConnection function, which will interact with our mocks.\n        //    Import dynamically because resetModules might affect the top-level import if used mid-test.\n        //    Using require ensures we get the potentially fresh module instance.\n        try {\n            const { closeDBConnection: closeAfterTest } = require('./db');\n            await closeAfterTest();\n        } catch (error) {\n             // Ignore errors during cleanup to prevent cascading test failures\n             // console.error(\"Error during afterEach cleanup:\", error);\n        }\n\n        // 2. Clean up any environment variables set during a test.\n        delete process.env.DATABASE_PATH;\n    });\n    it('should close the active connection successfully', async () => {\n        const { getDBConnection } = require('./db');\n        // Arrange: Establish a connection first.\n        const promiseConnect = getDBConnection();\n        process.nextTick(() => capturedConstructorCallback(null));\n        await jest.advanceTimersByTimeAsync(0);\n        process.nextTick(() => capturedPragmaCallback(null));\n        await jest.advanceTimersByTimeAsync(0);\n        await promiseConnect; // Ensure connection is established and db instance is set internally\n\n        // Act: Call the function to close the connection.\n        const closePromise = closeDBConnection();\n\n        // Assert: The mock database's close method should have been called.\n        expect(mockCloseFn).toHaveBeenCalledTimes(1);\n        expect(capturedCloseCallback).toBeDefined(); // Ensure the callback was captured.\n\n        // Act: Simulate the close callback succeeding.\n        process.nextTick(() => capturedCloseCallback(null));\n        await jest.advanceTimersByTimeAsync(0);\n\n        // Assert: The promise returned by closeDBConnection should resolve.\n        await expect(closePromise).resolves.toBeUndefined();\n\n        // --- Verify Internal State Reset ---\n        // Arrange: Attempt to get a connection again.\n        const promiseReconnect = getDBConnection();\n\n        // Assert: The constructor should be called again, indicating the previous instance was cleared.\n        expect(MockDatabaseConstructor).toHaveBeenCalledTimes(2);\n\n        // Cleanup: Complete the second connection attempt for isolation.\n        process.nextTick(() => capturedConstructorCallback(null));\n        await jest.advanceTimersByTimeAsync(0);\n        process.nextTick(() => capturedPragmaCallback(null));\n        await jest.advanceTimersByTimeAsync(0);\n        await promiseReconnect;\n    });\n\n    it('should do nothing and resolve immediately if no connection is active', async () => {\n        // Arrange: Ensure no connection exists (default state after beforeEach).\n\n        // Act: Call closeDBConnection.\n        const closePromise = closeDBConnection();\n\n        // Assert: The promise should resolve immediately.\n        await expect(closePromise).resolves.toBeUndefined();\n        // Assert: Neither the constructor nor the close method should have been called.\n        expect(MockDatabaseConstructor).not.toHaveBeenCalled();\n        expect(mockCloseFn).not.toHaveBeenCalled();\n    });\n\n    it('should resolve immediately if connection attempt is pending but not finished', async () => {\n        const { getDBConnection } = require('./db');\n        // Arrange: Start a connection attempt but *do not* trigger its callbacks yet.\n        const connectPromise = getDBConnection();\n        expect(MockDatabaseConstructor).toHaveBeenCalledTimes(1); // Constructor called, but callback pending\n\n        // Act: Call close while the connection promise (connectionPromise in db.ts) is pending.\n        const closePromise = closeDBConnection();\n\n        // Assert: closeDBConnection should resolve quickly because the internal 'db' variable is still null.\n        // It should *not* wait for the pending connection, nor call db.close().\n        await expect(closePromise).resolves.toBeUndefined();\n        expect(mockCloseFn).not.toHaveBeenCalled();\n\n        // --- Verify Subsequent Behavior ---\n        // Act: Now, let the original pending connection succeed.\n        process.nextTick(() => capturedConstructorCallback(null));\n        await jest.advanceTimersByTimeAsync(0);\n        process.nextTick(() => capturedPragmaCallback(null));\n        await jest.advanceTimersByTimeAsync(0);\n\n        // Assert: The original connection promise should eventually resolve.\n        await expect(connectPromise).resolves.toBeDefined();\n\n        // Act: Try getting the connection again.\n        // Because closeDBConnection was called (and likely nulled the internal 'db' and 'connectionPromise' refs\n        // even though the actual db object wasn't ready to close), a new connection attempt should start.\n        const connectPromise2 = getDBConnection();\n\n        // Assert: A new connection attempt is made.\n        expect(MockDatabaseConstructor).toHaveBeenCalledTimes(2);\n\n        // Cleanup second attempt\n        process.nextTick(() => capturedConstructorCallback(null));\n        await jest.advanceTimersByTimeAsync(0);\n        process.nextTick(() => capturedPragmaCallback(null));\n        await jest.advanceTimersByTimeAsync(0);\n        await connectPromise2;\n    });\n\n\n    it('should reject if closing the underlying database connection fails', async () => {\n        const { getDBConnection } = require('./db');\n        // Arrange: Establish a connection first.\n        const promiseConnect = getDBConnection();\n        process.nextTick(() => capturedConstructorCallback(null));\n        await jest.advanceTimersByTimeAsync(0);\n        process.nextTick(() => capturedPragmaCallback(null));\n        await jest.advanceTimersByTimeAsync(0);\n        await promiseConnect; // Connection established\n\n        // Arrange: Define the error for the close operation.\n        const closeError = new Error('Failed to close DB file handle');\n\n        // Act: Call closeDBConnection.\n        const closePromise = closeDBConnection();\n\n        // Assert: The mock close method was called.\n        expect(mockCloseFn).toHaveBeenCalledTimes(1);\n        expect(capturedCloseCallback).toBeDefined();\n\n        // Act: Simulate the close callback failing with an error.\n        process.nextTick(() => capturedCloseCallback(closeError));\n        await jest.advanceTimersByTimeAsync(0);\n\n        // Assert: The promise returned by closeDBConnection should reject.\n        await expect(closePromise).rejects.toThrow(\`Failed to close database: ${closeError.message}\`);\n\n        // --- Verify Internal State Reset (even on error) ---\n         // Arrange: Attempt to get a connection again.\n        const promiseReconnect = getDBConnection();\n\n        // Assert: The constructor should be called again, indicating the internal refs were cleared despite the close error.\n        expect(MockDatabaseConstructor).toHaveBeenCalledTimes(2);\n\n        // Cleanup: Complete the second connection attempt.\n        process.nextTick(() => capturedConstructorCallback(null));\n        await jest.advanceTimersByTimeAsync(0);\n        process.nextTick(() => capturedPragmaCallback(null));\n        await jest.advanceTimersByTimeAsync(0);\n        await promiseReconnect;\n    });\n});\n`