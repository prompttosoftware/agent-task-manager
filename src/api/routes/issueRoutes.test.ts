import express from 'express';
import request from 'supertest';
import issueRoutes from './issueRoutes';
import * as issueController from '../controllers/issueController';
import * as issueService from '../../services/issueService';

// Mock the issueService module
jest.mock('../../services/issueService');

describe('issueRoutes', () => {
  let app: express.Application;
  const mockCreateIssueService = issueService.createIssue as jest.Mock;

  // Set up the Express app before each test
  beforeEach(() => {
    app = express();
    // Add middleware to parse JSON body
    app.use(express.json());
    // Use the issue routes
    app.use('/', issueRoutes);

    // Reset mocks before each test
    mockCreateIssueService.mockClear();
  });

  // Test case for POST /rest/api/2/issue using the real controller and mocked service
  test('POST /rest/api/2/issue should create issue and return 201 with issue data', async () => {
    // Arrange
    // The request body now follows a nested structure { fields: { ... }, parent: { ... } }
    const sampleRequestBody = {
      fields: {
        summary: 'Test Issue',
        description: 'This is a test issue description.',
        project: { key: 'TEST' },
        issuetype: { name: 'Task' },
      }
      // You could add parent here like:
      // parent: { key: 'PROJECT-123' }
      // if you wanted to test the controller's handling of parent,
      // but the service currently doesn't use it.
    };

    // Expected data that the service mock will return (flat structure as per service definition)
    // The controller extracts these fields from the nested request body.
    const expectedCreatedIssue = {
      id: 'mock-issue-id-123', // Service mock will return a fixed ID
      summary: sampleRequestBody.fields.summary,
      description: sampleRequestBody.fields.description,
      project: sampleRequestBody.fields.project.key,
      issueType: sampleRequestBody.fields.issuetype.name,
      // Add any other fields the service is expected to add/return (e.g., status, key, etc.)
    };

    // Mock the service function implementation to return the expected data
    mockCreateIssueService.mockResolvedValueOnce(expectedCreatedIssue);

    // Act
    const response = await request(app)
      .post('/rest/api/2/issue')
      .send(sampleRequestBody)
      .set('Accept', 'application/json');

    // Assert
    expect(response.status).toBe(201);
    expect(response.body).toEqual(expectedCreatedIssue);

    // Verify that the service function was called exactly once
    expect(mockCreateIssueService).toHaveBeenCalledTimes(1);

    // Verify that the service function was called with the flat data extracted by the controller
    // from the request body, plus the generated UUID.
    expect(mockCreateIssueService).toHaveBeenCalledWith(
      expect.objectContaining({
        id: expect.any(String), // Expecting a UUID generated by the controller
        summary: sampleRequestBody.fields.summary,
        description: sampleRequestBody.fields.description,
        project: sampleRequestBody.fields.project.key,
        issueType: sampleRequestBody.fields.issuetype.name,
      })
    );
  });

  // Test case for POST /rest/api/2/issue handling 500 from service
  test('POST /rest/api/2/issue should return 500 status for service error', async () => {
    // Arrange
    const sampleRequestBody = {
      fields: {
        summary: 'Test Issue for 500',
        description: 'This issue should trigger a service error.',
        project: { key: 'ERROR' }, // Example project key that might cause an error in service
        issuetype: { name: 'Bug' },
      },
    };
    const serviceErrorMessage = 'Database connection failed'; // Simulate an error from the service

    // Mock the service function implementation to throw an error
    mockCreateIssueService.mockRejectedValueOnce(new Error(serviceErrorMessage));

    // Act
    const response = await request(app)
      .post('/rest/api/2/issue')
      .send(sampleRequestBody)
      .set('Accept', 'application/json');

    // Assert
    expect(response.status).toBe(500);
    // The controller wraps the service error message
    expect(response.body).toEqual({ message: 'Failed to create issue', error: serviceErrorMessage });

    // Verify that the service function was called exactly once with the correct data
    expect(mockCreateIssueService).toHaveBeenCalledTimes(1);
    expect(mockCreateIssueService).toHaveBeenCalledWith(
      expect.objectContaining({
        id: expect.any(String),
        summary: sampleRequestBody.fields.summary,
        description: sampleRequestBody.fields.description,
        project: sampleRequestBody.fields.project.key,
        issueType: sampleRequestBody.fields.issuetype.name,
      })
    );
  });

  // --- New test cases for validation errors (400 status) ---

  test('POST /rest/api/2/issue should return 400 for missing "fields"', async () => {
    // Arrange
    const sampleRequestBody = {
      // Missing the required 'fields' object
      parent: { key: 'PROJECT-123' }
    };
    const expectedErrorMessage = 'Missing required field: "fields".';

    // Act
    const response = await request(app)
      .post('/rest/api/2/issue')
      .send(sampleRequestBody)
      .set('Accept', 'application/json');

    // Assert
    expect(response.status).toBe(400);
    expect(response.body).toEqual({ message: expectedErrorMessage });
    expect(mockCreateIssueService).not.toHaveBeenCalled(); // Service should not be called on validation failure
  });

  test('POST /rest/api/2/issue should return 400 for missing "fields.summary"', async () => {
    // Arrange
    const sampleRequestBody = {
      fields: {
        // summary is missing
        description: 'This is a test issue description.',
        project: { key: 'TEST' },
        issuetype: { name: 'Task' },
      },
    };
    const expectedErrorMessage = 'Invalid or missing field: "fields.summary". It must be a non-empty string.';

    // Act
    const response = await request(app)
      .post('/rest/api/2/issue')
      .send(sampleRequestBody)
      .set('Accept', 'application/json');

    // Assert
    expect(response.status).toBe(400);
    expect(response.body).toEqual({ message: expectedErrorMessage });
    expect(mockCreateIssueService).not.toHaveBeenCalled();
  });

  test('POST /rest/api/2/issue should return 400 for empty "fields.summary"', async () => {
    // Arrange
    const sampleRequestBody = {
      fields: {
        summary: '   ', // empty summary
        description: 'This is a test issue description.',
        project: { key: 'TEST' },
        issuetype: { name: 'Task' },
      },
    };
    const expectedErrorMessage = 'Invalid or missing field: "fields.summary". It must be a non-empty string.';

    // Act
    const response = await request(app)
      .post('/rest/api/2/issue')
      .send(sampleRequestBody)
      .set('Accept', 'application/json');

    // Assert
    expect(response.status).toBe(400);
    expect(response.body).toEqual({ message: expectedErrorMessage });
    expect(mockCreateIssueService).not.toHaveBeenCalled();
  });

  test('POST /rest/api/2/issue should return 400 for empty "fields.issuetype.name"', async () => {
    // Arrange
    const sampleRequestBody = {
      fields: {
        summary: 'Test Issue',
        description: 'This is a test issue description.',
        project: { key: 'TEST' },
        issuetype: { name: '   ' }, // Empty issue type name
      },
    };
    const expectedErrorMessage = 'Invalid or missing field: "fields.issuetype.name". It must be a non-empty string.';

    // Act
    const response = await request(app)
      .post('/rest/api/2/issue')
      .send(sampleRequestBody)
      .set('Accept', 'application/json');

    // Assert
    expect(response.status).toBe(400);
    expect(response.body).toEqual({ message: expectedErrorMessage });
    expect(mockCreateIssueService).not.toHaveBeenCalled();
  });

  test('POST /rest/api/2/issue should return 400 for missing "fields.issuetype.name"', async () => {
    // Arrange
    const sampleRequestBody = {
      fields: {
        summary: 'Test Issue',
        description: 'This is a test issue description.',
        project: { key: 'TEST' },
        issuetype: { /* name is missing */ },
      },
    };
    const expectedErrorMessage = 'Invalid or missing field: "fields.issuetype.name". It must be a non-empty string.';

    // Act
    const response = await request(app)
      .post('/rest/api/2/issue')
      .send(sampleRequestBody)
      .set('Accept', 'application/json');

    // Assert
    expect(response.status).toBe(400);
    expect(response.body).toEqual({ message: expectedErrorMessage });
    expect(mockCreateIssueService).not.toHaveBeenCalled();
  });

  test('POST /rest/api/2/issue should return 400 for invalid "fields.issuetype.name"', async () => {
    // Arrange
    const sampleRequestBody = {
      fields: {
        summary: 'Test Issue',
        description: 'This is a test issue description.',
        project: { key: 'TEST' },
        issuetype: { name: 'InvalidType' }, // Invalid issue type
      },
    };
    const expectedErrorMessage = 'Invalid value for "fields.issuetype.name". Allowed values are: Bug, Task, Story.';

    // Act
    const response = await request(app)
      .post('/rest/api/2/issue')
      .send(sampleRequestBody)
      .set('Accept', 'application/json');

    // Assert
    expect(response.status).toBe(400);
    expect(response.body).toEqual({ message: expectedErrorMessage });
    expect(mockCreateIssueService).not.toHaveBeenCalled();
  });

  test('POST /rest/api/2/issue should return 400 for empty "fields.project.key"', async () => {
    // Arrange
    const sampleRequestBody = {
      fields: {
        summary: 'Test Issue',
        description: 'This is a test issue description.',
        project: { key: '   ' }, // Empty project key
        issuetype: { name: 'Task' },
      },
    };
    const expectedErrorMessage = 'Invalid or missing field: "fields.project.key". It must be a non-empty string.';

    // Act
    const response = await request(app)
      .post('/rest/api/2/issue')
      .send(sampleRequestBody)
      .set('Accept', 'application/json');

    // Assert
    expect(response.status).toBe(400);
    expect(response.body).toEqual({ message: expectedErrorMessage });
    expect(mockCreateIssueService).not.toHaveBeenCalled();
  });

  test('POST /rest/api/2/issue should return 400 for missing "fields.project.key"', async () => {
    // Arrange
    const sampleRequestBody = {
      fields: {
        summary: 'Test Issue',
        description: 'This is a test issue description.',
        // project is missing
        issuetype: { name: 'Task' },
      },
    };
    const expectedErrorMessage = 'Invalid or missing field: "fields.project.key". It must be a non-empty string.';

    // Act
    const response = await request(app)
      .post('/rest/api/2/issue')
      .send(sampleRequestBody)
      .set('Accept', 'application/json');

    // Assert
    expect(response.status).toBe(400);
    expect(response.body).toEqual({ message: expectedErrorMessage });
    expect(mockCreateIssueService).not.toHaveBeenCalled();
  });

  test('POST /rest/api/2/issue should return 400 for missing "parent.key" when "parent" is present', async () => {
    // Arrange
    const sampleRequestBody = {
      fields: {
        summary: 'Sub-task',
        description: 'This is a sub-task description.',
        project: { key: 'PROJECT' },
        issuetype: { name: 'Task' }, // Assuming Sub-task is allowed if parent is provided
      },
      parent: {
        // key is missing
      }
    };
    // Note: Controller currently only checks for Bug, Task, Story. Sub-task would fail validation
    // first. Let's adjust issuetype or the test expectation. Use a valid type.
    // sampleRequestBody.fields.issuetype.name = 'Task';

    const expectedErrorMessage = 'Invalid or missing field: "parent.key". It must be a non-empty string if "parent" is provided.';

    // Act
    const response = await request(app)
      .post('/rest/api/2/issue')
      .send(sampleRequestBody)
      .set('Accept', 'application/json');

    // Assert
    expect(response.status).toBe(400);
    expect(response.body).toEqual({ message: expectedErrorMessage });
    expect(mockCreateIssueService).not.toHaveBeenCalled();
  });

  test('POST /rest/api/2/issue should return 400 for invalid "parent.key" format', async () => {
    // Arrange
    const invalidParentKey = 'PROJECT123'; // Missing hyphen
    const sampleRequestBody = {
      fields: {
        summary: 'Sub-task',
        description: 'This is a sub-task description.',
        project: { key: 'PROJECT' },
        issuetype: { name: 'Task' }, // Use a valid type
      },
      parent: {
        key: invalidParentKey,
      }
    };
    const expectedErrorMessage = `Invalid format for "parent.key": "${invalidParentKey}". Expected format like "PROJECT-123".`;

    // Act
    const response = await request(app)
      .post('/rest/api/2/issue')
      .send(sampleRequestBody)
      .set('Accept', 'application/json');

    // Assert
    expect(response.status).toBe(400);
    expect(response.body).toEqual({ message: expectedErrorMessage });
    expect(mockCreateIssueService).not.toHaveBeenCalled();
  });

   test('POST /rest/api/2/issue should return 400 for parent key project mismatch', async () => {
    // Arrange
    const sampleRequestBody = {
      fields: {
        summary: 'Sub-task',
        description: 'This is a sub-task description.',
        project: { key: 'PROJ' }, // Project key PROJ
        issuetype: { name: 'Task' }, // Use a valid type
      },
      parent: {
        key: 'ANOTHER-123', // Parent key from ANOTHER project
      }
    };
    const expectedErrorMessage = 'Project key "PROJ" must match the project prefix of the parent key "ANOTHER-123". Expected "ANOTHER".';

    // Act
    const response = await request(app)
      .post('/rest/api/2/issue')
      .send(sampleRequestBody)
      .set('Accept', 'application/json');

    // Assert
    expect(response.status).toBe(400);
    expect(response.body).toEqual({ message: expectedErrorMessage });
    expect(mockCreateIssueService).not.toHaveBeenCalled();
  });

  test('POST /rest/api/2/issue should return 201 with valid parent key', async () => {
    // Arrange
    const sampleRequestBody = {
      fields: {
        summary: 'Sub-task',
        description: 'This is a sub-task description.',
        project: { key: 'PROJECT' },
        issuetype: { name: 'Task' }, // Use a valid type
      },
      parent: {
        key: 'PROJECT-123',
      }
    };

    const expectedCreatedIssue = {
      id: 'mock-issue-id-123',
      summary: sampleRequestBody.fields.summary,
      description: sampleRequestBody.fields.description,
      project: sampleRequestBody.fields.project.key,
      issueType: sampleRequestBody.fields.issuetype.name,
      parentKey: sampleRequestBody.parent.key // Correct key for parent
    };


    mockCreateIssueService.mockResolvedValueOnce(expectedCreatedIssue);

    // Act
    const response = await request(app)
      .post('/rest/api/2/issue')
      .send(sampleRequestBody)
      .set('Accept', 'application/json');

    // Assert
    expect(response.status).toBe(201);
    expect(response.body).toEqual(expectedCreatedIssue);
    // Explicitly assert the parentKey in the response body
    expect(response.body.parentKey).toBe(sampleRequestBody.parent.key);
    expect(mockCreateIssueService).toHaveBeenCalledTimes(1);
    expect(mockCreateIssueService).toHaveBeenCalledWith(
      expect.objectContaining({
        id: expect.any(String),
        summary: sampleRequestBody.fields.summary,
        description: sampleRequestBody.fields.description,
        project: sampleRequestBody.fields.project.key,
        issueType: sampleRequestBody.fields.issuetype.name,
        parentKey: sampleRequestBody.parent.key, // Verify parent key is passed
      })
    );
  });
});
