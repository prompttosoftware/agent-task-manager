import request from 'supertest';
import express, { Request, Response, NextFunction } from 'express';
import epicRoutes from '../routes/epicRoutes';
import { Issue } from '../../models/issue'; // Import the TYPE 'Issue'
// import * as issueModel from '../../models/issue'; // Import the MODULE exports (which will be mocked)
import { DatabaseService } from '../../services/databaseService';
import { IssueKeyService } from '../../services/issueKeyService';
import { EpicController } from './epicController';
import { createMock } from '@golevelup/ts-jest';

// Mock the '../../models/issue' module.
// The factory function returns the exports of the mocked module.
// We configure it to export an object named 'Issue' which contains our mock functions.
// jest.mock('../../models/issue', () => ({
//     // __esModule: true, // Typically needed for ES Modules interop with CommonJS mocks
//     // Mock the 'Issue' object/class exported by the actual module.
//     // This object should contain the static methods like 'create' and 'findAll'.
//     Issue: {
//         create: jest.fn(),
//         findAll: jest.fn(),
//     },
// }));

jest.mock('../../services/databaseService', () => ({
    DatabaseService: jest.fn(() => ({
        run: jest.fn(),
        get: jest.fn(),
        all: jest.fn(),
    }))
}));

jest.mock('../../services/issueKeyService', () => ({
    IssueKeyService: jest.fn(() => ({
        getNextIssueKey: jest.fn().mockResolvedValue('TEST-123'),
    }))
}));

// After jest.mock runs, the import * as issueModel will now import the mock object.
// We need to access the 'Issue' property within the mocked module's exports.
// Using a type assertion because TypeScript doesn't know the shape defined in jest.mock's factory.
// const MockedIssueModel = (issueModel as any).Issue as {
//     create: jest.Mock;
//     findAll: jest.Mock;
// };


describe('Epic Controller - POST /', () => {
    let app: express.Application;
    // let mockCreate: jest.Mock;
    // let mockFindAll: jest.Mock; // Keep reference for potential use and resetting
    let epicController: EpicController;
    let databaseService: jest.Mocked<DatabaseService>;
    let issueKeyService: jest.Mocked<IssueKeyService>;

    beforeEach(async () => {
        app = express();
        app.use(express.json());

        // Create mock instances of DatabaseService and IssueKeyService
        databaseService = createMock<DatabaseService>();
        issueKeyService = createMock<IssueKeyService>();
        (issueKeyService.getNextIssueKey as jest.Mock).mockResolvedValue('TEST-123');

        // Instantiate EpicController with mock dependencies
        epicController = new EpicController(databaseService, issueKeyService);

        // Create the router with the epicController
        const router = epicRoutes(epicController);

        app.use('/', router); // Mount routes which use the Issue model

        // Reset the mock implementation before each test
        // Access the mock functions from our MockedIssueModel reference
        // mockCreate = MockedIssueModel.create;
        // mockCreate.mockReset();
        // mockFindAll = MockedIssueModel.findAll;
        // mockFindAll.mockReset(); // Reset findAll as well for clean state

        // Add a generic error handler for tests expecting 500 errors
        // This should ideally be placed after the route setup
        app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
            console.error("Test Error Handler Caught:", err.stack); // Log error in test output
            // Ensure a default message if none exists
            const message = err.message || 'Internal Server Error';
            res.status(500).send({ message });
        });
    });

    it('should return a 201 status code and the created epic data on successful creation', async () => {
        // Arrange: Define the data sent in the request and the expected response
        // Use Omit if _id is usually generated by the database and not sent in request
        const newEpicData: Omit<Issue, '_id' | 'key' | 'issuetype'> = {
            summary: 'New Epic',
            description: 'New Epic Description',
            // key might also be generated, adjust as needed based on actual model/controller
        };
        const createdEpic: Issue = { // This is the object the mocked 'create' should return
            _id: 'new-epic-id-123',
            issuetype: 'Epic',
            key: 'PROJ-1', // Assuming key is generated/returned
            ...newEpicData,
        };
        // Configure the mock 'create' method to resolve successfully
        // mockCreate.mockResolvedValue(createdEpic);

        (databaseService.run as jest.Mock).mockResolvedValue(undefined);
        (databaseService.get as jest.Mock).mockResolvedValue(createdEpic);

        // Act: Make a POST request to the endpoint
        const response = await request(app)
            .post('/')
            .send(newEpicData); // Send the input data

        // Assert: Check the status code and the response body
        expect(response.statusCode).toBe(201);
        expect(response.body).toEqual(createdEpic); // Response should match the created object

        // Verify: Ensure that the create method was called with the correct arguments
        // The controller likely adds issuetype: 'Epic' or it might be passed in. Adjust if needed.
        // expect(mockCreate).toHaveBeenCalledWith(expect.objectContaining(newEpicData));
    });

    it('should return a 500 status code and an error message if epic creation fails', async () => {
        // Arrange: Configure the mock 'create' method to reject with an error
        const errorMessage = 'Database error during epic creation';
        const error = new Error(errorMessage);
        // mockCreate.mockRejectedValue(error);
        (databaseService.run as jest.Mock).mockRejectedValue(error);

        const newEpicData: Omit<Issue, '_id' | 'key' | 'issuetype'> = {
            summary: 'Failing Epic',
            description: 'This creation should fail',
        };


        // Act: Make a POST request to the endpoint
        const response = await request(app)
            .post('/')
            .send(newEpicData);

        // Assert: Check the status code and the response body
        expect(response.statusCode).toBe(500);
        expect(response.body).toEqual({ message: errorMessage }); // Error message should be passed through

        // Verify: Ensure that the create method was called with the correct arguments
        // expect(mockCreate).toHaveBeenCalledWith(expect.objectContaining(newEpicData));
    });
});


describe('Epic Controller - GET /', () => {
    let app: express.Application;
    // let mockFindAll: jest.Mock;
    let epicController: EpicController;
    let databaseService: jest.Mocked<DatabaseService>;
    let issueKeyService: jest.Mocked<IssueKeyService>;

    beforeEach(async () => {
        app = express();
        app.use(express.json());

        // Create mock instances of DatabaseService and IssueKeyService
        databaseService = createMock<DatabaseService>();
        issueKeyService = createMock<IssueKeyService>();
        (issueKeyService.getNextIssueKey as jest.Mock).mockResolvedValue('TEST-123');

        // Instantiate EpicController with mock dependencies
        epicController = new EpicController(databaseService, issueKeyService);

        const router = epicRoutes(epicController);
        app.use('/', router);

        // Access the mock function correctly and reset
        // mockFindAll = MockedIssueModel.findAll;
        // mockFindAll.mockReset();

        // Mock error handler
        app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
            console.error("Test Error Handler Caught:", err.stack);
            const message = err.message || 'Failed to retrieve epics'; // Use error message or default
            res.status(500).send({ message });
        });
    });

    it('should return a 200 status code and the list of epics when successful', async () => {
        // Arrange: Mock the findAll method to simulate a successful retrieval
        // Use the imported Issue TYPE for the array elements
        const epics: Issue[] = [
            {
                _id: 'epic-id-1',
                issuetype: 'Epic',
                summary: 'Epic 1',
                description: 'Epic Description 1',
                key: 'EPIC-1',
            },
            {
                _id: 'epic-id-2',
                issuetype: 'Epic',
                summary: 'Epic 2',
                description: 'Epic Description 2',
                key: 'EPIC-2',
            },
        ];
        // Configure mock 'findAll' to resolve with the list of epics
        // Assuming the controller calls findAll perhaps with a filter for issuetype: 'Epic'
        // mockFindAll.mockResolvedValue(epics);
        (databaseService.all as jest.Mock).mockResolvedValue(epics);

        // Act: Make a GET request to the endpoint
        const response = await request(app)
            .get('/');

        // Assert: Check the status code and the response body
        expect(response.statusCode).toBe(200);
        expect(response.body).toEqual(epics);

        // Verify: Ensure that the findAll method was called
        // Add specific argument checks if the controller applies filters, e.g.
        // expect(mockFindAll).toHaveBeenCalledWith({ where: { issuetype: 'Epic' } });
        // expect(mockFindAll).toHaveBeenCalled(); // Basic check that it was called
    });

    it('should return a 500 status code when Issue.findAll method fails', async () => {
        // Arrange: Mock the findAll method to throw an error
        const errorMessage = 'Database connection lost';
        const error = new Error(errorMessage);
        // mockFindAll.mockRejectedValue(error);
        (databaseService.all as jest.Mock).mockRejectedValue(error);


        // Act: Make a GET request to the endpoint
        const response = await request(app)
            .get('/');

        // Assert: Check the status code and the response body
        expect(response.statusCode).toBe(500);
        expect(response.body).toEqual({ message: errorMessage }); // Expect the specific error message

        // Verify: Ensure that the findAll method was called
        // expect(mockFindAll).toHaveBeenCalled();
    });
});
